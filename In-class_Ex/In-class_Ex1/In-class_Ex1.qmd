---
title: "In-class Exercise 1"
editor: visual
---

## Overview

This is my first in-class exercise for geospatial analytics! We will review the key components of Hands-on Exercise 1 and learn more using the data from the In-class Exercise 1 zip file.

## Getting Started

### R packages

The code chunk below will install and load **tidyverse** and **sf** packages.

```{r}
pacman::p_load(tidyverse, sf)
```

**pacman** is a wrapper that wraps an installation package and a loading package, so that the package(s) is/are installed and loaded in one breath without having to use *install.packages()* + *library()*.

The syntax *pacman::* is necessary because while the package **pacman** is installed, it is not loaded. Hence, it needs to be specified so that R knows to use *p_load()* from **pacman** package.

When rendering, R is making sure that **tidyverse** and **sf** packages are installed.

To view the (local) webpage in web browser, using the bottom right-hand quadrant of the RStudio \> Files \> ISSS624 folder \> \_site \> In-class Ex \> In-class Ex1 \> In-class Ex1.html \> left-click select View in Web Browser.

### Data

Unzip **Hands-on_Ex1**, copy the **data** folder to C:/zhuyiting1/ISSS624/In-class_Ex/In-class_Ex1. It should be in the same folder as In-class_Ex1.qmd.

## Importing Geospatial Data

### Importing Polygon Features

This code chunk will import ESRI shapefile into R.

```{r}
mpsz <- st_read(dsn = "data/geospatial",
                layer = "MP14_SUBZONE_WEB_PL")
```

To read the syntax of the function, select the function name in the code and press F1. The Help page in the bottom right-hand quadrant of RStudio will open up.

The *dsn* argument is to tell st_read() where is the destination (relative path). As the code document (qmd file) is in the same directory as the data folder, we can start from "data/" to call the data folder within.

*Pro tip: Using the bottom right-hand quadrant, go to Files tab, go to the folder/subfolder that we are trying to import the data (in this case* data/geospatial*) and look at the folder and file names to key in as inputs for* st_read()*.*

From the output, we can obtain a couple of information including:

-   Projected CRS: **SVY21** (Singapore-based projected coordinates system). Not in degrees format.

-   Unit of measurement: metres.

Under Environment tab in the top right-hand quadrant of RStudio, `mpsz` data is loaded in R. Clicking on the blue \|\> button to the left of `mpsz`, we can take a quick peek of the dataframe. Up to the first 10 records are displayed (to save space). To look at the dataframe in greater detail, click on the dataframe name `mpsz` to open the full data table.

### Importing and Transforming into Projected Coordinate System

Decimal degree format (between 0^o^ and 360^o^) good for exact location but not for distance measurement. This is because the Earth is ellipsoid and the distance gets closer further away from the equator in this format.

On the other hand, projected coordinate system flattens the Earth. This makes the distance roughly equivalent no matter where we are.

*Reading:* [Geographic vs Projected Coordinate Systems](https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/)

To convert **wgs84** (geographic coordinate system) to **svy21** (Singapore projected coordinate system), use the function *st_transform()* and argument *crs = 3414.*

The following code chunk imports the pre-schools location data (kml file) and pipes it into the transformation step in one sitting.

```{r}
preschool = st_read("data/geospatial/pre-schools-location-kml.kml") %>% 
  st_transform(crs = 3414)
```

While the output above still indicates geodetic CRS **wgs84**, when we click on preschool in the Environment tab to open the data table, we can see that the geometry values are no longer in degree decimal format.

![](images/paste-1345DB90.png)

## In-class Exercise 1

## Importing Shapefile Data

Now, let's add the In-class Ex 1 data in the data folder.

We will also need the **spdep** package for this exercise. We do it by including it in the *p_load()* function. As it requires the **spData** package, we will install and load it as well. Finally, we need the **tmap** package for quick plots.

```{r}
pacman::p_load(spData, tidyverse, sf, spdep, tmap)
```

We also want to do some housekeeping to keep our laptop memory freed up from unused datasets. In the Environment tab, click on the broom logo to remove unused datasets.

![](images/paste-58FFA92D.png){width="371"}

Now we want to import the Hunan ESRI shapefile into R. This is the Hunan county boundary layer.

```{r}
hunan <- st_read(dsn = "data/geospatial",
                layer = "Hunan")
```

We can see that the data is in geodetic CRS **wgs84**.

## Importing Attribute Data in CSV

### Aspatial Hunan Data

The code chunk below imports the aspatial Hunan 2012 data. This dataset contains selected local development indicators such as Gross Domestic Product per capita (`GDPPC`) for each county in 2012.

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

## Joining Hunan Data

The code chunk below joins the spatial and aspatial data for Hunan using the [*left_join()*](https://dplyr.tidyverse.org/reference/mutate-joins.html) function of the **dplyr** package.

```{r}
hunan <- left_join(hunan, hunan2012)
```

R recognises the variable "County" to be the only common variable between the two dataframes and performs the join accordingly. As the two dataframes have the exact same number of observations with matching county, *left_join()* here works the same as a *inner_join()*, *right_join()* and *full_join()*. It appends the `hunan2012` data to the right of the original `hunan` data. Notably, the geometry column from the original `hunan` dataframe remains at the rightmost column of the new `hunan` dataframe.

## Visualising Regional Development Indicator

With some data about the Hunan province, we want to create a quick thematic map to visualise the distribution of GDPPC in 2012, using the [*qtm()*](https://www.rdocumentation.org/packages/tmap/versions/3.3-3/topics/qtm) function from the **tmap** package.

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("County", size=0.5)

gdppc <- qtm(hunan, fill = "GDPPC")

tmap_arrange(basemap, gdppc, asp = 1, ncol = 2)
```

We see that *qtm()* does a quick plot using equal interval classification. From the map, most regions (\~60%) have GDPPC of only 1/5 of the wealthiest region. In addition, we observe that the wealth is mostly concentrated in the Northeast region of the Hunan province, and the top tier GDPPC in 2012 was held by only 1 county - Changsha.

## Computing Contiguity Spatial Weights

In this section, we will use *poly2nb()* of **spdep** to compute contiguity weights matrices for the study area, Hunan. This function builds a neighbours list based on regions with contiguous (shared) boundaries. The default criteria used in this function is Queen's criteria, which considers any boundary that is touching by at least 1 point to be a neighbour.

![](images/paste-DB966401.png){width="603"}

### Computing (Queen's Criteria) Contiguity-based Neighbours

The code chunk below computes Queen's contiguity weights matrix.

```{r}
wm_q <- poly2nb(hunan, queen = TRUE)
summary(wm_q)
```

There are 448 pairs of neighbours found by the Queen\'s case, from the 88 counties in Hunan. From the summary report, the link number distributions shows the frequency of the number of links or neighbours that each county has, the most being 11 neighbours for 1 county (region 85). On the other extreme, the 2 least connected regions (30 and 65) only have 1 neighbour each.

By calling the `County` column of the `hunan` dataframe, we can see that the county with the most neighbours is `Taoyuan` and that with the least neighbours are `Xinhuang` and `Linxiang`. This is consistent with the basemap that we plotted previously, where `Taoyuan` is a large county in the North surrounded by multiple smaller counties, and `Xinhuang` and `Linxiang` being counties along the West and Northeast borders of Hunan respectively.

```{r}
hunan$County[c(85, 30, 65)]
```

For each polygon in our polygon object, *wm_q()* lists all neighboring polygons. For example, to see the neighbours for the region with the most number of neighbours (polygon number 85), we can use the following code chunk.

```{r}
wm_q[[85]]
```

The 11 neighbours of Polygon 85, which is Taoyuan, are listed above. The numbers represent the polygon IDs as stored in the `hunan` SpatialPolygonsDataFrame class.

To retrieve the GDPPC of Taoyuan and all its 11 neighbours, the following code chunk can be used.

```{r}
nb85 <- wm_q[[85]]
nb85 <- hunan$GDPPC[c(85, nb85)]
nb85
```

We can see that the GDPPC of Taoyuan and its 11 neighbours (based on Queen's criteria) are 22879, 23667, 20981, 34592, 25554, 27137, 24194, 14567, 21311, 18714, 14624 and 19509 respectively.

The complete weights matrix can be listed using [*str()*](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/str) (display internal structure) from R's **utils** package.

```{r}
str(wm_q)
```

### Computing (Rook's Criteria) Contiguity-based Neighbours
