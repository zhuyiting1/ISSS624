[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I learned how to import, wrangle and visualise geospatial data using the appropriate R packages."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#data-sources",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#data-sources",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Data Sources",
    "text": "Data Sources\nThe data used in this exercise are obtained from the following sources on 18 November 2022:\n\nMaster Plan 2014 Subzone Boundary (Web)\nPre-schools Location\nCycling Path\nAirbnb Singapore Listings - scroll down to Singapore, download listings.csv\n\n#1-3 are geospatial data while #4 is in .csv with latitude and longitude information."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#getting-started",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#getting-started",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below installs and loads sf and tidyverse packages into the R environment.\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#importing-geospatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#importing-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Importing Geospatial Data",
    "text": "Importing Geospatial Data\n\nImporting Polygon Feature Data\nFrom the sf package, use st_read() function to import MP14_SUBZONE_WEB_PL shapefile into R as a polygon feature dataframe.\n\nmpsz <- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\zhuyiting1\\ISSS624\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nThere are 323 features and 15 fields in the \\(mpsz\\) dataframe. The geometry type is multipolygon. It is in the svy21 projected coordinates system.\n\n\nImporting Polyline Feature Data\nFrom the sf package, similarly use st_read() function to import CyclingPathGazette shapefile into R as a line feature dataframe.\n\ncyclingpath = st_read(dsn = \"data/geospatial\",\n                      layer = \"CyclingPathGazette\")\n\nReading layer `CyclingPathGazette' from data source \n  `C:\\zhuyiting1\\ISSS624\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 2248 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\nThere are 2248 features and 2 fields in the \\(cyclingpath\\) dataframe. The geometry type is multilinestring. It is also in the svy21 projected coordinates system.\n\n\nImporting KML Data\nAs above, from the sf package, use st_read() function to import pre-schools-location-kml file into R. However, as the data format is .kml, we will use the following format instead of the earlier dsn and layer arguments:\n\npreschool = st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\zhuyiting1\\ISSS624\\Hands-on_Ex1\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1925 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nThere are 1925 features and 2 fields in the \\(preschool\\) dataframe. The geometry type is point. Unlike \\(mpsz\\) and \\(cyclingpath\\), it is in the wgs84 geodetic coordinates system. We will need to transform the data to svy21 coordinates system later.\n\n\nKnowing the Data\nTop-line geometry information of the mpsz dataframe:\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\nThe multipolygon information of the first 5 geometries are shown.\nNext, we will use glimpse() of the dplyr package:\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nglimpse() shows the data type of each field (int, chr, date, dbl (double-precision values)) and the first few entries for each field.\nFor complete information of a feature object, head() from R’s built-in package can give us the first n rows of the dataframe:\n\nhead(mpsz, n=5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30..."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#plotting-the-geospatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#plotting-the-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Plotting the Geospatial Data",
    "text": "Plotting the Geospatial Data\nplot() from R Graphic allows us to visualise the geospatial features of the data that we cannot easily pick up in plain rows and columns.\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nThe default plot of an sf object is a multi-plot of all attributes, up to a reasonable maximum. We can also specify only plotting the geometry or a specific attribute (like the 6th plot above) as shown below:\n\nplot(st_geometry(mpsz))\n\n\n\nplot(mpsz[\"PLN_AREA_N\"])"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#map-projection",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#map-projection",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Map Projection",
    "text": "Map Projection\nSimilar to data preprocessing for the usual dataframe, geoprocessing should be done to ensure that the data are projected using the same coordinate system. We will be using projection transformation to project a simple feature dataframe from one coordinate system to another.\n\nAssigning EPSG Code\nAlways check for the coordinate system of the source data, which can be done as such:\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nWith reference to the last part of the output (CS[Cartesian,2]), the EPSG code is 9001. However, for svy21, the correct EPSG code should be 3414. We want to assign the correct EPSG code to the \\(mpsz\\) dataframe, using st_set_crs() of the sf package.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nChecking that it has been performed successfully:\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nNow the ID under USAGE indicates “EPSG”, 3414.\n\n\nTransforming Projection from wgs84 to svy21\nGeographic coordinate system is transformed to projected coordinate system here to allow for analysis using distance and/or area measurements. For the \\(preschool\\) dataframe, as we saw earlier that the geodetic CRS is wgs84, it is not appropriate to use st_set_crs() like we did for $mpsz$. Instead, st_transform() from the same sf package can help us do the job. This is because we need to reproject \\(preschool\\) from one coordinate system to another mathematically.\n\npreschool3414 <- st_transform(preschool, \n                              crs = 3414)\n# In practice, we need to find the appropriate projection coordinate system to use before perfroming the projection transformation.\n\nChecking the projected coordinate system:\n\nst_geometry(preschool3414)\n\nGeometry set for 1925 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25596.33 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (13258.34 35611.04 0)\n\n\nPOINT Z (35272.09 41373.42 0)\n\n\nPOINT Z (25050.54 46634.14 0)\n\n\nPOINT Z (22892.48 46127.66 0)\n\n\nPOINT Z (34155.79 41949.13 0)\n\nst_crs(preschool3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nThe projected coordinate system has been revised to svy21. USAGE ID is now “EPSG”, 3414."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#working-with-aspatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#working-with-aspatial-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Working with Aspatial Data",
    "text": "Working with Aspatial Data\nRecall we are also using the listings.csv file from Inside Airbnb. The data is aspatial, as the data itself is not geospatial but it has data fields that capture the x- and y-coordinates of the data points.\n\nStep 1\nLoad the data into a dataframe \\(listings\\):\n\nlistings <- read_csv(\"data/aspatial/listings.csv\")\n\nRows: 4161 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (6): name, host_name, neighbourhood_group, neighbourhood, room_type, l...\ndbl  (11): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nUsing read_csv() from the readr package within tidyverse, we see that the dataframe with 4161 rows and 18 columns is imported to R.\n\n\nStep 2\nTo look at it in a bit more detail:\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,161 × 18\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   145\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    85\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    85\n 5 275344 15 mins… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    49\n 6 289234 Booking…  367042 Belinda East R… Tampin…    1.34    104. Privat…   184\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    79\n 8 324945 Cozy Bl… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    49\n 9 330089 Cozy Bl… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    55\n10 330095 10 mins… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    55\n# … with 4,151 more rows, 8 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>,\n#   number_of_reviews_ltm <dbl>, license <chr>, and abbreviated variable names\n#   ¹​host_name, ²​neighbourhood_group, ³​neighbourhood, ⁴​latitude, ⁵​longitude,\n#   ⁶​room_type\n\n\nWe see that the \\(latitude\\) and \\(longitude\\) data fields form 2 of the columns, and are in decimal degree format. As a best guess, we will assume that the data is in wgs84 geographic coordinate system.\n\n\nStep 3\nConvert \\(listings\\) dataframe into a simple feature dataframe and perform transformation to projected coordinate system:\n\nlistings_sf <- st_as_sf(listings, \n                        coords = c(\"longitude\", \"latitude\"), # coords argument takes in x-coordinates before y-coordinates\n                        crs = 4326) %>% # 4326 is the wgs84 geographic coordinate system\n  st_transform(crs = 3414) # %>% performs nested st_transform() to svy21 projected coordinate system\n\nglimpse(listings_sf) # shows the topline info of the transformed data\n\nRows: 4,161\nColumns: 17\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275344, 289…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 145, 85, 85, 49, 184, 79, 49, 55, 5…\n$ minimum_nights                 <dbl> 92, 92, 92, 92, 60, 92, 92, 60, 60, 60,…\n$ number_of_reviews              <dbl> 18, 20, 24, 47, 14, 12, 133, 17, 12, 3,…\n$ last_review                    <date> 2014-12-26, 2020-01-17, 2019-10-13, 20…\n$ reviews_per_month              <dbl> 0.18, 0.15, 0.18, 0.34, 0.11, 0.10, 1.0…\n$ calculated_host_listings_count <dbl> 1, 6, 6, 6, 44, 6, 7, 44, 44, 44, 6, 7,…\n$ availability_365               <dbl> 365, 340, 265, 365, 296, 285, 365, 181,…\n$ number_of_reviews_ltm          <dbl> 0, 0, 0, 0, 1, 0, 0, 3, 2, 0, 1, 0, 0, …\n$ license                        <chr> NA, NA, NA, NA, \"S0399\", NA, NA, \"S0399…\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\n\\(latitude\\) and \\(longitude\\) columns are dropped as they have been used to generate the new \\(geometry\\) column in svy21 projected coordinate system."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#geoprocessing---buffering",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#geoprocessing---buffering",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Geoprocessing - Buffering",
    "text": "Geoprocessing - Buffering\nTo compute a 5-metre buffer on both ends of the current cycling path using the \\(cyclingpath\\) dataframe:\n\nbuffer_cycling_5m <- st_buffer(cyclingpath,\n                               dist = 5,\n                               nQuadSegs = 30)\n\nWe can see that buffer_cycling_5m is as follows:\n\nbuffer_cycling_5m\n\nSimple feature collection with 2248 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 11849.32 ymin: 28342.98 xmax: 42631.09 ymax: 48953.15\nProjected CRS: SVY21\nFirst 10 features:\n   PLANNING_A PLANNING_1                       geometry\n1        <NA>       <NA> POLYGON ((16004.15 36799.78...\n2        <NA>       <NA> POLYGON ((16013.15 36849.86...\n3        <NA>       <NA> POLYGON ((16016.91 36892.98...\n4        <NA>       <NA> POLYGON ((16017.59 36864, 1...\n5        <NA>       <NA> POLYGON ((16022.36 36900.57...\n6        <NA>       <NA> POLYGON ((15903.87 36941.12...\n7        <NA>       <NA> POLYGON ((17791.37 34725.6,...\n8        <NA>       <NA> POLYGON ((17845.19 34694.74...\n9        <NA>       <NA> POLYGON ((16719.51 36124.49...\n10       <NA>       <NA> POLYGON ((17027.74 36260.02...\n\n\nWe then add a new variable in buffer_cycling_5m to calculate the area of the buffer:\n\nbuffer_cycling_5m$AREA <- st_area(buffer_cycling_5m)\nbuffer_cycling_5m\n\nSimple feature collection with 2248 features and 3 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 11849.32 ymin: 28342.98 xmax: 42631.09 ymax: 48953.15\nProjected CRS: SVY21\nFirst 10 features:\n   PLANNING_A PLANNING_1                       geometry           AREA\n1        <NA>       <NA> POLYGON ((16004.15 36799.78... 186.2934 [m^2]\n2        <NA>       <NA> POLYGON ((16013.15 36849.86... 293.4840 [m^2]\n3        <NA>       <NA> POLYGON ((16016.91 36892.98... 284.8275 [m^2]\n4        <NA>       <NA> POLYGON ((16017.59 36864, 1... 144.8915 [m^2]\n5        <NA>       <NA> POLYGON ((16022.36 36900.57... 281.2016 [m^2]\n6        <NA>       <NA> POLYGON ((15903.87 36941.12... 398.7081 [m^2]\n7        <NA>       <NA> POLYGON ((17791.37 34725.6,... 937.4688 [m^2]\n8        <NA>       <NA> POLYGON ((17845.19 34694.74... 426.5907 [m^2]\n9        <NA>       <NA> POLYGON ((16719.51 36124.49... 570.4396 [m^2]\n10       <NA>       <NA> POLYGON ((17027.74 36260.02... 319.0839 [m^2]\n\n\nWe can see that the new variable \\(AREA\\) in square metres is added.\nFinally, we will derive the total land involved by summing up all the \\(AREA\\):\n\nsum(buffer_cycling_5m$AREA)\n\n1556978 [m^2]\n\n\nWe get 1,556,978 m2 of area in total."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#geoprocessing---point-in-polygon-count",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#geoprocessing---point-in-polygon-count",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Geoprocessing - Point-in-Polygon Count",
    "text": "Geoprocessing - Point-in-Polygon Count\nAnother analysis that we can do is to find the number of pre-schools in each planning subzone. We will first identify pre-schools located within each planning subzone by using st_intersects() from the sf package. Next, length() of Base R is used to return the number of pre-schools by planning subzone.\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\nNote that the symbol used is ” ` ” (backtick) and not ” ’ ” (apostrophe).\nThe summary statistics of the newly derived \\(PreSch Count\\) is as follows:\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    3.00    5.96    9.00   58.00 \n\n\nTo list the planning subzone with the most number of pre-schools, top_n() from the dplyr package is used. In this case, the 1 planning subzone with the highest number of pre-school count and its information are displayed:\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 39655.33 ymin: 35966 xmax: 42940.57 ymax: 38622.37\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO     SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2 TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39   10180.62\n  SHAPE_Area                       geometry PreSch Count\n1    4339824 MULTIPOLYGON (((42196.76 38...           58\n\n\nNext, we try to calculate the density of pre-school by planning subzone:\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count` / Area * 1000000)\n# mutate() adds new variables and preserves existing ones, \n# whereas transmute() adds new variables and drops existing ones\n# * 1,000,000 converts the unit from per m sq to per km sq\n\n\nsummary(mpsz3414$`PreSch Density`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   4.203   5.538   9.380  35.602"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#exploratory-data-analysis-eda",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#exploratory-data-analysis-eda",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Exploratory Data Analysis (EDA)",
    "text": "Exploratory Data Analysis (EDA)\nTo study the \\(PreSch Density\\) data further, we will use appropriate ggplot2 function from the tidyverse package to visualise the data.\nFor distribution, we use the hist() function of R Graphics to plot a histogram:\n\nhist(mpsz3414$`PreSch Density`)\n\n\n\n\nHowever, this is only suitable for a quick glance of the histogram. To make the plot more presentable and usable (for publication), we tap on ggplot2 functions:\n\nggplot(data = mpsz3414,\n       aes(x = as.numeric(`PreSch Density`))) +\n  geom_histogram(bins = 20,\n                 color = \"black\",\n                 fill = \"light blue\") +\n  labs(title = \"Pre-school distribution in Singapore\",\n       subtitle = \"There are many planning sub-zones with only 1 single pre-school. \\n On the other hand, there are 2 planning sub-zones with at least 20 pre-schools.\",\n       x = \"Pre-school density (per km sq)\",\n       y = \"Frequency\")\n\n\n\n\nShowing a scatterplot between pre-school density and pre-school count:\n\nggplot(data = mpsz3414, \n       aes(x = as.numeric(`PreSch Density`), \n           y = as.numeric(`PreSch Count`))) + \n  geom_point() +\n  labs(x = \"Pre-school density (per km sq)\",\n       y = \"Pre-school count\")"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#choropleth-mapping",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#choropleth-mapping",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Choropleth Mapping",
    "text": "Choropleth Mapping\nWe will now use tmap (thematic maps) package in addition to sf and tidyverse that we used. Installing and loading all 3:\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#data-sources-1",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#data-sources-1",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Data Sources",
    "text": "Data Sources\nThe data used in this exercise are obtained from the following sources on 18 November 2022:\n\nMaster Plan 2014 Subzone Boundary (Web)\nSingapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format - scroll down and download respopagesextod2011to2020.csv"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#importing-data",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#importing-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Importing Data",
    "text": "Importing Data\n\nGeospatial Data\nUsing what we have learned:\n\nmpsz <- st_read(dsn = \"data/geospatial\",\n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\zhuyiting1\\ISSS624\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n\n\n\n\nAttribute Data\nImporting and examining the population data that we downloaded in data source #2:\n\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\npopdata\n\n# A tibble: 984,656 × 7\n   PA         SZ                     AG     Sex     TOD                Pop  Time\n   <chr>      <chr>                  <chr>  <chr>   <chr>            <dbl> <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   HDB 1- and 2-Ro…     0  2011\n 2 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   HDB 3-Room Flats    10  2011\n 3 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   HDB 4-Room Flats    30  2011\n 4 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   HDB 5-Room and …    50  2011\n 5 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   HUDC Flats (exc…     0  2011\n 6 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   Landed Properti…     0  2011\n 7 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   Condominiums an…    40  2011\n 8 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   Others               0  2011\n 9 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Females HDB 1- and 2-Ro…     0  2011\n10 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Females HDB 3-Room Flats    10  2011\n# … with 984,646 more rows"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#data-wrangling",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#data-wrangling",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Data Wrangling",
    "text": "Data Wrangling\nWe only want to use the 2022 values, and include the following variables:\n\nPA: Planning Area\nSZ: Subzone\nFrom AG (age group), create the following new variables:\n\nYOUNG: age group 0-4 to 20-24\nECONOMY ACTIVE: age group 25-29 to 60-64\nAGED: age group 65 and above\nTOTAL: all age group\nDEPENDENCY: ratio between young + aged against economy active group\n\n\n\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup() %>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+ \n         rowSums(.[13:15])) %>%\n  mutate(`AGED`=rowSums(.[16:21])) %>%\n  mutate(`TOTAL`=rowSums(.[3:21])) %>%\n  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, `ECONOMY ACTIVE`, `AGED`, `TOTAL`, `DEPENDENCY`)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#joining-data",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#joining-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Joining Data",
    "text": "Joining Data\nWe want to first convert the PA and SZ data fields to uppercase to be consistent with the SUBZONE_N and PLN_AREA_N data fields in \\(mpsz\\).\n\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ),\n            .funs = funs(toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nPlease use a list of either functions or lambdas: \n\n  # Simple named list: \n  list(mean = mean, median = median)\n\n  # Auto named with `tibble::lst()`: \n  tibble::lst(mean, median)\n\n  # Using lambdas\n  list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\n\nNext, left_join() from dplyr is used to join the geographical data from \\(mpsz\\) and attribute table from \\(popdata2020\\) using planning subzone names, in this case SUBZONE_N and SZ, as common identifiers. Left join with reference to \\(mpsz\\) is used to ensure that the output mpsz_pop2020 will be a simple features dataframe.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex01.html#choropleth-mapping-using-tmap",
    "href": "Hands-on_Ex1/Hands-on_Ex01.html#choropleth-mapping-using-tmap",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Choropleth Mapping using tmap",
    "text": "Choropleth Mapping using tmap\n\nQuick plot using qtm()\nDoing a cartographic standard choropleth map:\n\ntmap_mode(\"plot\") # gives static map; \"view\" for interactive mode\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020,\n    fill = \"DEPENDENCY\")\n\n\n\n\n\n\nCustomisable thematic map using tmap()’s elements\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by Planning Subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA) and\\n Population data from Department of Statistics (DOS)\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\nStep-by-Step Break-Down\n\n\n1) Base Map\nWe first use the tm_shape() function to define the input data and tm_polygons() function to draw the planning subzone polygons:\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\n2) Adding Colours (Choropleth Map)\nNext, we assign the target variable Dependency to tm_polygons() function to display a choropleth map showing the geographical distribution (like a map-based histogram):\n\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\nSome points to note for tm_polygons():\n\nThe default interval binning used to draw the choropleth map is called “pretty”. This style rounds breaks into whole numbers where possible and spaces them evenly.\nThe default colour scheme used is YlOrRd (Yellow Orange Red) of ColorBrewer.\nBy default, missing values will be shaded in grey.\n\n\n\n3) Using tm_fill() and tm_border() instead\ntm_polygons() is a wrapper of tm_fill() (shading) and tm_border() (borders).\n\ntm_shape(mpsz_pop2020) + \n  tm_fill(\"DEPENDENCY\")\n\n\n\n\nAbove is a map with fill only (coloured by dependencies in each planning subzone), no borders.\n\ntm_shape(mpsz_pop2020) + \n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1, alpha = 1)\n\n\n\n\nUsing tm_borders, we have added light grey borders (default colour “grey40”) with 0.1 line width and 1 for not transparent (default alpha uses that of the colour and is typically 1).\n\n\n4) Data Classification\nQuantile data classification:\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nData classification into 5 equal intervals between the minimum and the maximum values:\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nComparing the different styles available:\n\nstyle1 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"sd\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: SD\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\nstyle2 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: Equal\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\nstyle3 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"pretty\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: Pretty\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\nstyle4 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\",\n          title = \"Style: Quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: Quantile\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\nstyle5 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"kmeans\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: Kmeans\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\nstyle6 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fisher\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: Fisher\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\nstyle7 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: Jenks\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\nstyle8 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"headtails\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Style: Headtails\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.25, \n            legend.width = 0.35,\n            frame = TRUE)\n\ntmap_arrange(style1, style2, style3, style4, style5, style6, style7, style8, ncol = 4)\n\n\n\n\nBetween the styles shown above, Kmeans appear to give a more evenly balanced set of colours across subzones, followed by quantile.\nComparing same classification method with different number of classes:\n\nn2 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 2,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"2 Classes\",\n            main.title.position = \"center\",\n            main.title.size = 1.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            frame = TRUE)\nn6 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"6 Classes\",\n            main.title.position = \"center\",\n            main.title.size = 1.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            frame = TRUE)\nn10 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 10,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"10 Classes\",\n            main.title.position = \"center\",\n            main.title.size = 1.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            frame = TRUE)\nn20 <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 20,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"20 Classes\",\n            main.title.position = \"center\",\n            main.title.size = 1.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            frame = TRUE)\n\ntmap_arrange(n2, n6, n10, n20, ncol = 2)\n\n\n\n\nThe larger the number of classes, the finer the data classification and the more colours are seen in the choropleth map. For style = “jenks”, 6-10 classes appear to be optimal visually in differentiating the different gradients.\n\n\n5) Custom Breaks\nGetting some descriptive statistics of the DEPENDENCY field:\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nWith reference to the summary statistics, we set break points at 0.60, 0.70, 0.80 and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 100).\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 100)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\nWe note that the cutoffs are similar to our top pick for style (“kmeans”), which uses ~c(0, 0.5, 0.7, 0.8, 10, 19), and our first runner-up (“quantile”), at ~c(0, 0.6, 0.7, 0.8, 19).\n\n\n6) Colour Scheme\nUsing ColorBrewer palette = “Blues”:\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nInverse green:\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n7) Map Layouts - Legend\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by Planning Subzone\\n(Jenks Classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n8) Map Layouts - Style\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\nThe default tmap_style() is “white”.\n\n\n\n8) Map Layouts - Cartographic Furniture\nCartographic furniture refers to features such as compass, scale bar and grid lines.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby Planning Subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA) and\\n Population data from Department of Statistics (DOS)\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\ntmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n9) Multiple Choropleth Maps\nAssigning multiple values to at least 1 of the aesthetic arguments:\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5)\n\n\n\n\nAssigning different styles and colour palettes to each plot:\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\nDefining group-by variable in tm_facets():\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\nCreating multiple stand-alone maps with tmap_arrange() as we have done above:\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n10) Mapping Spatial Object Meeting a Selection Criterion\nHere, we select the “CENTRAL REGION” within REGION_N for display:\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend\n\n\n\n\n\nThe end :)"
  },
  {
    "objectID": "Hands-on_Ex1.html",
    "href": "Hands-on_Ex1.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This is the paragraph for overview."
  },
  {
    "objectID": "Hands-on_Ex1.html#getting-started",
    "href": "Hands-on_Ex1.html#getting-started",
    "title": "Hands-on Exercise 1",
    "section": "Getting Started",
    "text": "Getting Started\nThis is the paragraph for getting started."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html",
    "title": "Hands-on_Ex2",
    "section": "",
    "text": "This is my second hands-on exercise for geospatial analytics! I will apply what I learnt on global and local indicators of spatial association from my second geospatial lecture on the Hunan dataset from my earlier in-class exercise."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#data",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#data",
    "title": "Hands-on_Ex2",
    "section": "Data",
    "text": "Data\nUnzip Hands-on_Ex1, copy the data folder to C:/zhuyiting1/ISSS624/Hands-on_Ex2. It should be in the same folder as Hands-on_Ex2.qmd."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#importing-shapefile-data",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#importing-shapefile-data",
    "title": "Hands-on_Ex2",
    "section": "Importing Shapefile Data",
    "text": "Importing Shapefile Data\nIn addition to tidyverse (which includes dplyr) and sf packages that we used earlier, we will need the spdep package for this exercise. We do it by including it in the p_load() function. As it requires the spData package, we will install and load it as well. Finally, we need the tmap package for quick plots.\n\npacman::p_load(spData, tidyverse, sf, spdep, tmap)\n\nNow we want to import the Hunan shapefile into R.\n\nhunan <- st_read(dsn = \"data/geospatial\",\n                layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `C:\\zhuyiting1\\ISSS624\\Hands-on_Ex2\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\nWe can see that the data is in geodetic CRS wgs84."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#importing-attribute-data-in-csv",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#importing-attribute-data-in-csv",
    "title": "Hands-on_Ex2",
    "section": "Importing Attribute Data in CSV",
    "text": "Importing Attribute Data in CSV\n\nAspatial Hunan Data\nThe code chunk below imports the aspatial Hunan 2012 data.\n\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#joining-hunan-data",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#joining-hunan-data",
    "title": "Hands-on_Ex2",
    "section": "Joining Hunan Data",
    "text": "Joining Hunan Data\nThe code chunk below joins the spatial and aspatial data for Hunan using the left_join() function of the dplyr package.\n\nhunan <- left_join(hunan, hunan2012)\n\nJoining, by = \"County\"\n\n\nR recognises the variable County to be the only common variable between the two dataframes and performs the join accordingly. As the two dataframes have the exact same number of observations with matching county, left_join() here works the same as a inner_join(), right_join() and full_join(). It appends the hunan2012 data to the right of the original hunan data. Notably, the geometry column from the original hunan dataframe remains at the rightmost column of the new hunan dataframe."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#visualising-regional-development-indicator",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#visualising-regional-development-indicator",
    "title": "Hands-on_Ex2",
    "section": "Visualising Regional Development Indicator",
    "text": "Visualising Regional Development Indicator\nWith some data about the Hunan province, we want to create a quick thematic map to visualise the distribution of Gross Domestic Product Per Capita (GDPPC) in 2012, using the qtm() function from the tmap package.\n\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.3, \n            legend.width = 0.7)\n  \nquantile <- tmap::tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.3, \n            legend.width = 0.7)\n\ntmap_arrange(equal, quantile, asp = 1, ncol = 2)\n\n\n\n\nWe see that the equal interval classification map shows that most regions (~60%) have GDPPC of only 1/5 of the wealthiest region. In addition, we observe that the wealth is mostly concentrated in the Northeast region of the Hunan province."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#global-spatial-autocorrelation",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#global-spatial-autocorrelation",
    "title": "Hands-on_Ex2",
    "section": "Global Spatial Autocorrelation",
    "text": "Global Spatial Autocorrelation\nWe want to know whether such a distribution of GDPPC is by pure chance (randomness), and if not, whether there is a positive/negative correlation between neighbouring regions or outliers. To do this, we will compute the global spatial autocorrelation statistics and perform spatial complete randomness test for global spatial autocorrelation.\n\nContiguity Spatial Weights\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights are used to define the neighbouring relationships between the geographical units (i.e. counties) in the study area.\nIn the code chunk below, poly2nb() of the spdep package is used to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. The default option uses the Queen’s Case to define each county’s neighbours (queen=TRUE), which is what we will use here.\n\nwm_q <- poly2nb(hunan)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nThere are 448 pairs of neighbours found by the Queen’s case logic (i.e. all sides and corners that are touching each other, in other words at least 1 shared boundary point is needed for “neighbour” definition), from the 88 counties in Hunan. From the summary report, the link number distributions shows the frequency of the number of links or neighbours that each county has, the most being 11 neighbours for 1 county (region 85). On the other extreme, the 2 least connected regions (30 and 65) only have 1 neighbour each.\nBy calling the County column of the hunan dataframe, we can see that the county with the most neighbours is Taoyuan and that with the least neighbours are Xinhuang and Linxiang. This is consistent with the basemap that we plotted previously, where Taoyuan is a large county in the North surrounded by multiple smaller counties, and Xinhuang and Linxiang being counties along the West and Northeast borders of Hunan respectively.\n\nhunan$County[c(85, 30, 65)]\n\n[1] \"Taoyuan\"  \"Xinhuang\" \"Linxiang\"\n\n\n\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"County\", size = 0.5)\nbasemap\n\n\n\n\n\n\nRow-standardised Weights Matrix\nBased on the neighbour relationship determined by Queen’s Case above, we will assign spatial weights to each pairs of counties in the form of a weights matrix. Each row and each column represent 1 of the 88 counties, forming a 88 x 88 matrix. The numbers 1 and 0 are used to indicate between each row and column pair (e.g. region 1-2 represented by the value in the first row and second column), whether they are neighbours (1) or not (0). The values along the diagonal (from top left to bottom right) is always 0 as they represent the same region (e.g. 1-1, 2-2, etc.) Such a matrix is symmetrical along the same diagonal.\nAs each region has different number of neighbours, in practice, row-standardised weights are used instead of spatial weights. Row-standardisation is done by dividing the values in each row by the sum of that row, so that the weight is a relative fraction based on the total number of neighbours that the region has (proportion by row sum). Row-standardisation weights matrix ensures that the spatial parameter in many spatial stochastic processes are comparable between models. It is applicable where polygon features are defined by administrative boundaries. While this is the most intuitive way of summarising the neighbours’ values, this approach has a limitation in that polygons along the edges of the study area will base their lagged values on fewer polygons, thus potentially over- or under-estimating the true nature of the spatial correlation in the data. More robust options such as the binary coding could be explored.\nThe code chunk below performs row standardisation for spatial weights using the nb2listw() function from the spdep package, with input being an object of class nb. The default style is “W” which is row standardisation. Other styles include “B” for basic binary coding, “C” for globally standaridsation, “U” for C divided by the number of neighbours, and “S” for variance-stablising coding scheme. For the zero.policy, we will set it to TRUE to permit the weights list to be formed with zero-length weights vector, which means that weights vector of zero length are inserted for regions without neighbour in the neighbours list. Nevertheless, from the poly2nb() function above, we know that all regions have at least 1 neighbour.\n\nrswm_q <- nb2listw(wm_q,\n                   zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\n\nGlobal Spatial Autocorrelation: Moran’s I\nNext, we will perform Moran’s I statistical testing using moran.test() of spdep.\n\n\nMoran’s I Statistical Testing\nThe code chunk below performs Moran’s I statistical testing. Using an upper-tailed test, the null and alternative hypotheses are as follows:\nH0: The observed spatial patterns of GDPPC in Hunan in 2012 are not clustered (i.e. either random or dispersed).\nH1: The observed spatial patterns of GDPPC in Hunan in 2012 are clustered.\n\nmoran.test(hunan$GDPPC,\n           listw = rswm_q,\n           zero.policy = TRUE,\n           na.action = na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nWith a p-value of < 0.05, at 5% significant level and 95% confidence level, we reject H0. Hence, there is sufficient evidence to support that the observed spatial patterns of GDPPC in Hunan in 2012 are clustered. In fact, a positive Moran’s I statistic of 0.301 supports that there is positive clustering in the GDPPC in Hunan in 2012 (i.e. counties with higher GDPPC tend to be geographically clustered/neighbours).\n\n\nMonte Carlo Moran’s I\nWhen we doubt that the assumptions of Moran’s I (i.e. normality and randomisation) are true, we can use a Monte Carlo simulation under the assumption of no spatial pattern and assigning all regions the mean value. We then compare the actual Moran’s I to that of the randomly simulated distribution to obtain the p-value (pseudo significance).\nThe code chunk below performs permutation test for Moran’s I statistics by using moran.mc() of spdep. A total of 1000 simulations will be performed with the seed number 1234.\n\nset.seed(1234)\nbperm = moran.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999,\n                 zero.policy = TRUE,\n                 alternative = \"greater\",\n                 na.action = na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nUsing an upper-tailed test, we see that p-value = 0.001 is still < 0.05. We similarly reject H0 and conclude that at 5% significance level, there is sufficient evidence to support that the spatial distribution of GDPPC is positively clustered in Hunan in 2012.\n\n\nVisualising Monte Carlo Moran’s I\nIn the code chunk below, we will visualise the simulated Moran’s I test statistics by plotting the distribution of the statistical values as a histogram using hist() and abline() of R Graphics.\n\nmean(bperm$res[1:1000])\n\n[1] -0.01472993\n\nvar(bperm$res[1:1000])\n\n[1] 0.004466925\n\nsummary(bperm$res[1:1000])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06167 -0.02113 -0.01473  0.02617  0.30075 \n\n\n\nhist(bperm$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulated Moran's I\")\nabline(v = 0,\n       col = \"red\")\n\n\n\n\nFrom the distribution, we see that the simulated Moran’s I values are right-skewed, with a median below the 0 reference line. The Moran’s I of 0.301 falls on the narrow right-tail of the distribution, corroborating with our earlier result of it being statistically significant.\nThe above can similarly be done using ggplot2.\n\ndf <- data.frame(bperm$res)\nggplot(df,\n       aes(x = bperm$res)) +\n  geom_histogram(binwidth = 0.02,\n                 boundary = 0,\n                 color = \"black\",\n                 fill = \"grey\") +\n  geom_vline(xintercept = 0,\n             color = \"red\") + \n  labs(title = \"Histogram of simulated Moran's I\",\n       x = \"Simulated Moran's I\",\n       y = \"Frequency\") +\n  theme_bw() +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\nGlobal Spatial Autocorrelation: Geary’s C\nIn this section, we will perform Geary’s C statistical testing by using the geary.test() function of spdep. The same null and alternative hypotheses apply.\nH0: The observed spatial patterns of GDPPC in Hunan in 2012 are not clustered (i.e. either random or dispersed).\nH1: The observed spatial patterns of GDPPC in Hunan in 2012 are clustered.\n\ngeary.test(hunan$GDPPC, listw = rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nWith a p-value of < 0.05, at 5% significant level and 95% confidence level, we reject H0. Hence, there is sufficient evidence to support that the observed spatial patterns of GDPPC in Hunan in 2012 are clustered. In fact, a positive Geary’s C statistic of 0.691 < 1 (small c) supports that there is positive clustering in the GDPPC in Hunan in 2012 (i.e. counties with higher GDPPC tend to be geographically clustered/neighbours).\n\n\nMonte Carlo Geary’s C\nThe code chunk below performs permutation test for Geary’s C statistic using geary.mc() of spdep. We similarly set seed number of 1234 for the simulation for reproducible results.\n\nset.seed(1234)\nbperm = geary.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999)\nbperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe Monte Carlo simulation returned similar result of a significant p-value (0.001) at 5% significance level. Hence, we reject H0 and conclude that there is sufficient evidence to support that the spatial distribution of GDPPC in Hunan in 2012 is clustered.\n\n\nVisualising Monte Carlo Geary’s C\nLike we did for Moran’s I, we will plot a histogram to reveal the distribution of the simulated values of Geary’s C by using the following code chunks.\n\nmean(bperm$res[1:1000])\n\n[1] 1.004089\n\nvar(bperm$res[1:1000])\n\n[1] 0.007527444\n\nsummary(bperm$res[1:1000])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.6907  0.9501  1.0050  1.0041  1.0594  1.2722 \n\n\n\nhist(bperm$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulated Geary's C\")\nabline(v = 1,\n       col = \"red\")\n\n\n\n\nUnlike Moran’s I, the cutoff/value indicating randomness is 1 instead of 0, as indicated by the vertical red line in the histogram above. The Geary’s C value of 0.691 is very close to the extreme left of the distribution, supporting the statistically significant result that we saw using the statistical testing."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#spatial-correlogram",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#spatial-correlogram",
    "title": "Hands-on_Ex2",
    "section": "Spatial Correlogram",
    "text": "Spatial Correlogram\nSpatial correlograms are used to examine patterns of spatial autocorrelation. They show how correlated are pairs of spatial observations when you increase the distance (lag) between them - they are plots of some index of autocorrelation (Moran's I or Geary's c) against distance. Row standardisation is not needed.\n\nMoran’s I Correlogram\nIn the code chunk below, sp.correlogram() of spdep is used to compute a 1- to 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used is Moran’s I. The plot() of R’s base Graph is used to plot the output.\n\nMI_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = \"I\",\n                          style = \"W\")\nplot(MI_corr)\n\n\n\n\nFrom the plot, Moran’s I is positive for up to 4 lags, beyond which Moran’s I drops below 0. It is also noted that lag of 7 or more will return empty neighbour sets, in which case we set zero.policy = TRUE in the code chunk below and try to plot up to 10 lags.\n\nMI_corr_10 <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 10,\n                          method = \"I\",\n                          style = \"W\",\n                          zero.policy = TRUE)\nplot(MI_corr_10)\n\n\n\n\nComparing with the earlier plot, we see that the standard deviation for Moran’s I decreases from 1 to 6 lags, but increases thereafter with the introduction of zero-length weights vectors. Moran’s I also returns to a positive level from 9 lags, albeit with very large standard deviations.\nIn addition to this, it is necessary to examine the full statistical report as not all autocorrelation values are statistically significant. This is done using the print() function in the code chunk below.\n\nprint(MI_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nWe observe that at 5% significance level, the autocorrelation values are statistically significant for all lags between 1 and 6, except 4-lag.\n\nprint(MI_corr_10)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n          estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)   0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)   0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)   0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)   0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88)  -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88)  -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n7 (83)  -0.1598792  -0.0121951  0.0031980          -2.6115        0.009014 ** \n8 (67)  -0.1016594  -0.0151515  0.0051687          -1.2033        0.228869    \n9 (45)   0.0151929  -0.0227273  0.0101956           0.3755        0.707254    \n10 (19)  0.0210858  -0.0555556  0.0266889           0.4691        0.638973    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nWhen we include more lags by allowing zero-length weights vector, the autocorrelation is statistically significant at 5% significant level up to 7 lags.\n\n\nGeary’s C Correlogram\nIn the code chunk below, we perform a similar analysis using the sp.correlogram() function from the spdep package, except using Geary’s C global spatial autocorrelation. We also plot the output using plot() from R’s base Graph, and print() the full report for the p-values.\n\nGC_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = \"C\",\n                          style = \"W\")\nplot(GC_corr)\n\n\n\n\n\nprint(GC_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nWe see that the correlogram for Geary’s C has an opposite shape (concave) compared to that for Moran’s I (convex). This is because Moran’s I has a range of -1 to 1 and defines positive clustering with >0 values, while Geary’s C only has positive values with randomness at 1 and positive clustering between 0 and 1. In other words, larger Moran’s I implies positive clustering but larger Geary’s C implies negative clustering (dispersing).\nGeary’s C correlogram also shows larger standard deviations across lags when compared to Moran’s I. From the report, the autocorrelation values are statistically significant at 5% significance level for 1, 2 and 5 lags, less than that for Moran’s I."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#cluster-and-outlier-analysis",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#cluster-and-outlier-analysis",
    "title": "Hands-on_Ex2",
    "section": "Cluster and Outlier Analysis",
    "text": "Cluster and Outlier Analysis\nLocal Indicator of Spatial Association (LISA) is a subset of localised geospatial statistics methods for analysing the location-related tendency (clusters or outliers) in the attributes of geographically referenced data (points or area). The LISA for each observation gives an indication of the extent of significant spatial clustering of similar values around that observation. The sum of LISAs for all observations is proportional to a global indicator of spatial association.\nWe will apply local Moran’s I to detect clusters and/or outliers from the 2012 GDPPC of the Hunan province.\n\nLocal Moran’s I\nThe code chunk below computes the local Moran’s I using the localmoran() function of the spdep package. We will use the row standardised weights matrix here.\n\nfips <- order(hunan$County)\nlocalMI <- localmoran(hunan$GDPPC, rswm_q)\nhead(localMI)\n\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n\n\nWe obtain the following statistics for the first 6 output:\n\nIi: Local Moran statistic\nE.Ii: Expectation of local Moran statistic\nVar.Ii: Variance of local Moran statistic\nZ.Ii: Standard deviate of local Moran statistic\nPr(): p-value of local Moran statistic\n\nThe code chunk below lists the content of the local Moran matrix derived using printCoefmat() function from R’s Stats package, arranged by the County name in alphabetical order.\n\nprintCoefmat(data.frame(localMI[fips,], \n                        row.names = hunan$County[fips],\n                        check.names = FALSE))\n\n                       Ii        E.Ii      Var.Ii    Z.Ii Pr(z != E(Ii))    \nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -0.0725      0.9422301    \nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791      0.1391057    \nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -0.0663      0.9471636    \nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185      0.2230456    \nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  0.1293      0.8971056    \nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -0.0768      0.9387606    \nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590      0.0007822 ***\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895      0.1119416    \nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  0.6830      0.4946117    \nCili           7.3176e-02 -1.6747e-03  4.7902e-02  0.3420      0.7323546    \nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297      0.3031703    \nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159      0.1881947    \nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338      0.1023002    \nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  0.5120      0.6086619    \nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -0.9510      0.3415864    \nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305      0.3027630    \nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  0.7793      0.4357997    \nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  0.2627      0.7928094    \nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  0.1274      0.8986110    \nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  0.4629      0.6434065    \nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -0.2562      0.7978131    \nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  0.4349      0.6636633    \nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678      0.2855921    \nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -0.0475      0.9621124    \nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  0.5407      0.5887023    \nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  0.7969      0.4255374    \nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -0.5363      0.5917276    \nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204      0.3075618    \nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  0.7180      0.4727569    \nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759      0.2396152    \nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -0.0197      0.9843090    \nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543      0.1756424    \nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  0.4497      0.6529132    \nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  0.2342      0.8148123    \nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623      0.2451020    \nLi             1.0225e-03 -2.4048e-07  5.1060e-06  0.4526      0.6508382    \nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467      0.2952490    \nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335      0.0328837 *  \nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  0.3909      0.6959021    \nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -0.1768      0.8596957    \nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  0.1363      0.8915545    \nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972      0.0051555 ** \nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787      0.0376449 *  \nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690      0.1709996    \nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  0.9956      0.3194403    \nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  0.7166      0.4736044    \nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715      0.0003550 ***\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -0.1099      0.9125016    \nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274      0.0676458 .  \nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  0.7536      0.4511108    \nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698      3.049e-05 ***\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  0.7640      0.4448892    \nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  0.6771      0.4983276    \nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -0.7181      0.4726740    \nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  0.9797      0.3272227    \nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510      0.1467765    \nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583      0.0631298 .  \nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807      0.0928305 .  \nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -0.4773      0.6331568    \nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  0.0652      0.9480354    \nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  0.8536      0.3933400    \nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544      0.0636875 .  \nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002      0.0357113 *  \nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  0.5090      0.6107279    \nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582      0.2899569    \nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873      0.0001014 ***\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935      0.0282749 *  \nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213      1.551e-05 ***\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092      0.0704213 .  \nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539      0.0507157 .  \nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  0.4241      0.6715036    \nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  0.2667      0.7897221    \nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502      0.1210854    \nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  0.1929      0.8470456    \nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -0.0068      0.9945429    \nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726      0.1698803    \nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -0.6867      0.4922880    \nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202      0.2223756    \nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795      0.1390190    \nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409      0.2538993    \nYou            7.8750e-02 -7.2728e-03  1.2116e-01  0.2471      0.8048036    \nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  0.0069      0.9944802    \nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121      0.0699726 .  \nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  0.8608      0.3893219    \nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  0.9221      0.3564539    \nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855      0.2358293    \nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688      0.0001094 ***\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -0.7014      0.4830289    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAt 5% significance level, the p-value is significant for Changsha, Liling, Liuyang, Longhui, Miluo, Pingjiang, Taojiang, Wangcheng, Wugang, Xiangtan and Zhuzhou. We will display the results in the next section.\n\n\nMapping local Moran’s I\nBefore mapping the local Moran’s I, we want to append the local Moran’s I dataframe (i.e. localMI) to the hunan SpatialPolygonDataFrame. The code chunk below does this using the cbind() function from R base which combine the vectors as columns in the final matrix. We also rename the p-value (Pr.z….E.Ii) variable title to Pr.Ii for neatness.\n\nhunan.localMI <- cbind(hunan, localMI) %>%\n  rename(Pr.Ii = Pr.z....E.Ii..)\nhunan.localMI\n\nSimple feature collection with 88 features and 40 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 10 features:\n     NAME_2  ID_3    NAME_3   ENGTYPE_3 Shape_Leng Shape_Area    County\n1   Changde 21098   Anxiang      County   1.869074 0.10056190   Anxiang\n2   Changde 21100   Hanshou      County   2.360691 0.19978745   Hanshou\n3   Changde 21101    Jinshi County City   1.425620 0.05302413    Jinshi\n4   Changde 21102        Li      County   3.474325 0.18908121        Li\n5   Changde 21103     Linli      County   2.289506 0.11450357     Linli\n6   Changde 21104    Shimen      County   4.171918 0.37194707    Shimen\n7  Changsha 21109   Liuyang County City   4.060579 0.46016789   Liuyang\n8  Changsha 21110 Ningxiang      County   3.323754 0.26614198 Ningxiang\n9  Changsha 21111 Wangcheng      County   2.292093 0.13049161 Wangcheng\n10 Chenzhou 21112     Anren      County   2.240739 0.13343936     Anren\n       City avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC      GIO\n1   Changde    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667   5108.9\n2   Changde    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981  13491.0\n3   Changde    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592  10935.0\n4   Changde    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473  18402.0\n5   Changde    32667    564.1  7781.2  336.86  1538.7 10355.0 25554   8214.0\n6   Changde    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137  17795.0\n7  Changsha    40446  21415.0 43599.0 2473.10  4605.5 81113.0 63118  99254.0\n8  Changsha    40744  18662.0 49234.0 2448.90  4812.2 73250.0 62202 114145.0\n9  Changsha    45171  12122.0 48829.0 2285.50  3802.3 37488.0 70666 148976.0\n10 Chenzhou    28058   4598.9  6386.1  220.57  1454.7  4941.2 12761   4189.2\n      Loan   NIPCR  Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household\n1   2806.9  7693.7 1931 336.39 270.5 205.9  19.584  17.819     148.1\n2   4550.0  8269.9 2560 456.78 388.8 246.7  42.097  33.029     240.2\n3   2242.0  8169.9  848 122.78  82.1  61.7   8.723   7.592      81.9\n4   6748.0  8377.0 2038 513.44 426.8 227.1  38.975  33.938     268.5\n5    358.0  8143.1 1440 307.36 272.2 100.8  23.286  18.943     129.1\n6   6026.5  6156.0 2502 392.05 329.6 193.8  29.245  26.104     190.6\n7  23408.0 15719.0 6225 919.62 721.4 300.1  90.978  58.819     374.8\n8  18435.0 13763.0 4351 852.96 757.6 318.3  80.715  68.853     391.7\n9  10330.0 16495.0 1678 361.48 268.6 131.2  28.838  24.815     161.3\n10  2555.3  3271.8  970 290.82 255.4  99.4  33.171  17.505     104.6\n   Household_R NOIP Pop_R    RSCG  Pop_T      Agri Service Disp_Inc      RORP\n1        135.4   53 346.0  3957.9  528.3  4524.410 14100.0    16610 0.6549309\n2        208.7   95 553.2  4460.5  804.6  6545.350 17727.0    18925 0.6875466\n3         43.7   77  92.4  3683.0  251.8  2562.460  7525.0    19498 0.3669579\n4        256.0   96 539.7  7110.2  832.5  7562.340 53160.0    18985 0.6482883\n5        157.2   99 246.6  3604.9  409.3  3583.910  7031.0    18604 0.6024921\n6        184.7  122 399.2  6490.7  600.5  5266.510  6981.0    19275 0.6647794\n7        369.8  733 642.7 16233.0 1285.5 10844.470 26617.8    27345 0.4999611\n8        369.6  552 655.5 15623.0 1186.5 12804.480 18447.7    24020 0.5524652\n9        154.8  314 266.6  5623.3  533.4  5222.356  6648.6    27690 0.4998125\n10       121.9   34 243.2  2386.4  388.7  2357.764  3814.1    16072 0.6256753\n      ROREmp           Ii          E.Ii       Var.Ii        Z.Ii        Pr.Ii\n1  0.8041262 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904 0.9471636332\n2  0.8511756  0.025878173 -6.061953e-04 1.016664e-02  0.26266425 0.7928093714\n3  0.6686757 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705 0.9843089778\n4  0.8312558  0.001022468 -2.404783e-07 5.105969e-06  0.45259801 0.6508382339\n5  0.8856065  0.014814881 -6.829362e-05 1.449949e-03  0.39085814 0.6959020959\n6  0.8407091 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835 0.6331568039\n7  0.7844544  3.368821673 -7.750185e-02 1.518028e+00  2.79715225 0.0051555232\n8  0.8882011  1.560689600 -7.387766e-02 8.001247e-01  1.82735933 0.0676457604\n9  0.7430563  4.421958618 -1.106694e-01 1.359593e+00  3.88727819 0.0001013746\n10 0.8782065 -0.399322576 -7.011066e-03 7.034768e-02 -1.47912938 0.1391057404\n                         geometry\n1  POLYGON ((112.0625 29.75523...\n2  POLYGON ((112.2288 29.11684...\n3  POLYGON ((111.8927 29.6013,...\n4  POLYGON ((111.3731 29.94649...\n5  POLYGON ((111.6324 29.76288...\n6  POLYGON ((110.8825 30.11675...\n7  POLYGON ((113.9905 28.5682,...\n8  POLYGON ((112.7181 28.38299...\n9  POLYGON ((112.7914 28.52688...\n10 POLYGON ((113.1757 26.82734...\n\n\nThe code chunk below plots the local Moran’s I values and their statistical significance (based on p-values) using the choropleth mapping functions from the tmap package.\n\nlocalMI.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\",\n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"Local Moran statistics\") +\n  tm_borders(alpha = 0.5)\n\npvalue.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\",\n          breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette = \"-Blues\",\n          title = \"Local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp = 1, ncol = 2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nOn the left, we note regions of positive (blue) and negative (orange) Moran’s I statistics, indicative of positive and negative clustering relationships. On the right, we see that the p-values are significant at 5% significance level for the regions in darker shades of blue. They generally correspond to regions with high positive local Moran’s I statistics."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#creating-a-lisa-cluster-map",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#creating-a-lisa-cluster-map",
    "title": "Hands-on_Ex2",
    "section": "Creating a LISA Cluster Map",
    "text": "Creating a LISA Cluster Map\nThe LISA Cluster Map shows the significant locations colour coded by type of spatial autocorrelation. The first step is to plot the Moran scatterplot.\n\nPlotting Moran Scatterplot\nThe Moran scatterplot is an illustration of the relationship ebtween the values of the chosen attributes at each location and the average value of the same attribute at neighbouring locations.\nThe code chunk below plots the Moran scatterplot of GDPPC 2012 by using moran.plot() of spdep.\n\nnci <- moran.plot(hunan$GDPPC,\n                  rswm_q,\n                  labels = as.character(hunan$County),\n                  xlab = \"GDPPC 2012\",\n                  ylab = \"Spatially lagged GDPPC 2012\")\n\n\n\n\nThe Moran scatterplot can be interpreted by the 4 quadrants:\n\nTop-right (high-high): Positive autocorrelation, i.e. clusters (the region and its neighbours all have high values)\nBottom-left (low-low): Positive autocorrelation, i.e. clusters (the region and its neighbours all have low values)\nTop-left (low-high): Negative autocorrelation, i.e. outlier (low outlier among high neighbours)\nBottom-right (high-low): Negative autocorrelation, i.e. outlier (high outlier among low neighbours)\n\nWe see that most regions follow a cluster autocorrelation pattern rather than outlier pattern."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#plotting-moran-scatterplot-with-standardised-variables",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#plotting-moran-scatterplot-with-standardised-variables",
    "title": "Hands-on_Ex2",
    "section": "Plotting Moran Scatterplot with Standardised Variables",
    "text": "Plotting Moran Scatterplot with Standardised Variables\nFirst, we use scale() from base R to centre and scale the variables. Here, centering is done by subtracting the mean (omitting NAs) from the corresponding columns, and scaling is done by dividing the (centred) variables by their standard deviations. The as.vector() from the pbdDMAT package added at the end of the code chunk below is to ensure that the data type for hunan$Z.GDPPC is a non-distributed vector instead of a distributed matrix. This is so that we can then append it to our dataframe later.\n\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% as.vector\n\nPlotting the Moran scatterplot again using the code chunk below, this time as nci2.\n\nnci2 <- moran.plot(hunan$Z.GDPPC,\n                   rswm_q,\n                   labels = as.character(hunan$County),\n                   xlab = \"z-GDPPC 2012\",\n                   ylab = \"Spatially lagged z-GDPPC 2012\")\n\n\n\n\nWe see that the x- and y-axes are scaled to 0 (for the division of the 4 quadrants).\n\nPreparing LISA Map Classes\nThe code chunks below show the steps to prepare a LISA cluster map.\n\nquadrant <- vector(mode = \"numeric\",\n                   length = nrow(localMI))\n\nNext, we centre the variable of interest around its mean.\n\nDV <- hunan$GDPPC - mean(hunan$GDPPC)\n\nThis is followed by centering the local Moran’s I around its mean.\n\nC_mI <- localMI[, 1] - mean(localMI[, 1])\n\nThen, we set a statistical significance level for local Moran’s at 5%.\n\nsignif <- 0.05\n\nThe next 4 command lines define the high-high, low-low, low-high and high-low quadrants.\n\nquadrant[DV < 0 & C_mI < 0] <- 1\nquadrant[DV < 0 & C_mI > 0] <- 2\nquadrant[DV > 0 & C_mI < 0] <- 3\nquadrant[DV > 0 & C_mI > 0] <- 4\n\nFinally, we place the non-significant Moran’s value in category 0.\n\nquadrant[localMI[,5] > signif] <- 0\n\nIn fact, we can combine all the steps into a single code chunk below.\n\nquadrant <- vector(mode = \"numeric\",\n                   length = nrow(localMI))\nDV <- hunan$GDPPC - mean(hunan$GDPPC)\nC_mI <- localMI[, 1] - mean(localMI[, 1])\nsignif <- 0.05\nquadrant[DV < 0 & C_mI < 0] <- 1\nquadrant[DV < 0 & C_mI > 0] <- 2\nquadrant[DV > 0 & C_mI < 0] <- 3\nquadrant[DV > 0 & C_mI > 0] <- 4\nquadrant[localMI[,5] > signif] <- 0\n\n\n\nPlotting LISA Map\nFinally, we can build the LISA map using the code chunk below.\n\ngdppc <- qtm(hunan, \"GDPPC\", fill.palette = \"Blues\")\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", # white for non-significant Moran's values\n            \"#f1fa73\", # yellow for low-low\n            \"#91fa5c\", # green for low-high\n            \"#5cfacb\", # cyan for high-low\n            \"#1239ff\") # blue for high-high\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)\n\ntmap_arrange(gdppc, LISAmap, asp=1, ncol=2)\n\n\n\n\nThe plot on the right shows that the statistically significant Moran’s I values are in blue for high-high autocorrelation and yellow for low-low autocorrelation (clusters). These regions are all found on the East side of the Hunan province, and they generally correspond to the higher GDPPC regions (see plot on the left). It also shows 3 outlier regions in green and cyan."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#hot-spot-and-cold-spot-area-analysis",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#hot-spot-and-cold-spot-area-analysis",
    "title": "Hands-on_Ex2",
    "section": "Hot Spot and Cold Spot Area Analysis",
    "text": "Hot Spot and Cold Spot Area Analysis\nBesides detecting clusters and outliers, localised spatial statistics can also be used to detect hot and/or cold spot areas.\nThe term ‘hot spot’ has been used generically across disciplines to describe a region or value that is higher relative to its surroundings.\n\nGetis and Ord’s G-Statistics\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord's G-statistics. It looks at neighbours within a defined proximity to identify where either high or low values clutser spatially. Here, statistically significant hot-spots are recognised as areas of high values where other areas within a neighbourhood range also share high values too.\nThe analysis consists of three steps:\n\nDeriving spatial weight matrix\nComputing Gi statistics\nMapping Gi statistics\n\n\n\nDeriving Distance-based Weights Matrix\nFirst, we need to define a new set of neighbours based on distance for Getis-Ord, instead of shared borders used for spatial autocorrelation.\nThere are two types of distance-based proximit matrix, namely:\n\nFixed distance weights matrix; and\nAdaptive distance weights matrix.\n\n\n\nDeriving the Centroid\nDistance-based weights matrix requires the centroids of the polygons to be determined.\nTo do this, we need the coordinates in a separate dataframe using a mapping function. The mapping function applies a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of the sf object us.bound. The function used is st_centroid() from sf package. We will use map_dbl() variation of map() from the purrr package.\nTo get our longitude values we map the st_centroid() function over the geometry column of us.bound and access the longitude value through double bracket notation [[ ]] and value 1. This allows us to get only the longitude, which is the first value in each centroid.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nWe do the same for latitude with one key difference. We access the second value per each centroid with [[2]] for latitude.\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nNow that we have latitude and longitude, we use cbind() to put longitude and latitude into the same object.\n\ncoords <- cbind(longitude, latitude)\ncoords\n\n      longitude latitude\n [1,]  112.1531 29.44362\n [2,]  112.0372 28.86489\n [3,]  111.8917 29.47107\n [4,]  111.7031 29.74499\n [5,]  111.6138 29.49258\n [6,]  111.0341 29.79863\n [7,]  113.7065 28.23215\n [8,]  112.3460 28.13081\n [9,]  112.8169 28.28918\n[10,]  113.3534 26.57906\n[11,]  113.8942 25.98122\n[12,]  112.4006 25.63215\n[13,]  112.5542 25.33880\n[14,]  113.6636 25.54967\n[15,]  112.9206 25.26722\n[16,]  113.1883 26.21248\n[17,]  113.4521 25.93480\n[18,]  112.4209 26.36132\n[19,]  113.0152 27.08120\n[20,]  112.6350 26.75969\n[21,]  112.7087 27.27930\n[22,]  112.9095 26.42079\n[23,]  111.9522 26.80117\n[24,]  110.2606 27.89384\n[25,]  110.0921 27.54115\n[26,]  109.7985 26.91321\n[27,]  109.5765 26.54507\n[28,]  109.7211 27.78801\n[29,]  109.7339 26.21157\n[30,]  109.1537 27.22941\n[31,]  110.6442 27.83407\n[32,]  110.5916 28.57282\n[33,]  109.5984 27.39828\n[34,]  111.4783 27.67997\n[35,]  112.1745 27.46256\n[36,]  111.2315 27.86930\n[37,]  110.3149 26.32113\n[38,]  111.3248 26.48991\n[39,]  110.5859 27.10164\n[40,]  110.9593 27.34884\n[41,]  111.8296 27.18765\n[42,]  110.1926 26.70972\n[43,]  110.7334 26.78494\n[44,]  110.9123 26.54354\n[45,]  111.4599 27.42910\n[46,]  112.5268 27.92456\n[47,]  112.3406 27.77407\n[48,]  109.5602 28.66808\n[49,]  109.5071 28.01142\n[50,]  109.9954 28.60033\n[51,]  109.4273 28.42749\n[52,]  109.7587 28.31518\n[53,]  109.5044 29.21940\n[54,]  109.9899 28.16053\n[55,]  109.9664 29.01206\n[56,]  111.3785 28.28449\n[57,]  112.4350 29.23817\n[58,]  112.5558 28.97135\n[59,]  111.7379 24.97087\n[60,]  112.1831 25.31559\n[61,]  111.9743 25.65101\n[62,]  111.7009 25.91101\n[63,]  112.2196 25.88615\n[64,]  112.6472 29.48614\n[65,]  113.5102 29.49285\n[66,]  113.1172 28.79707\n[67,]  113.7089 28.76024\n[68,]  112.7963 28.71653\n[69,]  110.9276 29.39439\n[70,]  113.6420 26.80361\n[71,]  113.4577 27.66123\n[72,]  113.8404 26.37989\n[73,]  113.4758 27.17064\n[74,]  113.1428 27.62875\n[75,]  110.3017 29.39053\n[76,]  113.1957 29.25343\n[77,]  111.7410 26.36035\n[78,]  112.1831 28.49854\n[79,]  111.3390 27.01465\n[80,]  111.8208 27.75124\n[81,]  110.0753 27.23539\n[82,]  112.3965 27.08323\n[83,]  112.7683 25.82828\n[84,]  113.1679 28.30074\n[85,]  111.4495 28.95406\n[86,]  112.7956 27.68910\n[87,]  111.5896 25.49530\n[88,]  111.2393 25.19355\n\n\ncoords now has 2 columns to indicate the longitude and latitude for the centroid of each region.\n\n\nDetermining Cut-off Distance\nWe want to determine the upper limit for distance band using the following steps:\n\nReturn a matrix with indices of points belonging to the set of k nearest neighbours of each other by using knearneigh() of spdep.\nConvert the knn object returned by knearneigh() into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids using knn2nb() of spdep.\nReturn the length of neighbour relationship edges by using nbdists() of spdep. The function returns in the units of the coordinates if the coordinates are projected, and in km otherwise. As the Hunan data was in geodesic CRS, the unit will be in km.\nRemove the list structure of the returned object by using unlist() of base R.\n\n\nk1 <- knn2nb(knearneigh(coords, k = 1))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79km. We will use this as the upper threshold to ensure that all units will have at least 1 neighbour.\n\n\nComputing Fixed Distance Weights Matrix\nNow, we will compute the distance weights matrix by using dnearneigh() of spdep.\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n324 links were made between the 88 regions.\nNext, nb2listw() of spdep is used to convert the nb object into spatial weights object. A binary style is used to indicate whether a pair of region is neighbours (1) or not (0).\n\nwm62_lw <- nb2listw(wm_d62, style = \"B\")\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\nHere, we see that 6 regions only have 1 neighbour each, while the maximum number of neighbours defined by 62km distance between centroids is 6, compared to the earlier definition by Queen’s Case of 11.\n\n\nComputing Adaptive Distance Weights Matrix\nOne of the characteristics of fixed distance weights matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours than the less densely settled areas (usually the rural areas). Having many neighbours smoothes the neighbour relationship across more neighbours.\nIt is possible to control the number of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry. In this case, we will set all regions to have 8 neighbours each (k = 8). Such an adaptive weighting scheme will use shorter distances or bandwidths where data are dense and longer where data are sparse.\n\nknn <- knn2nb(knearneigh(coords, k = 8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\nSimilarly, nb2listw() of spdep is used to convert the nb object into spatial weights object in binary style.\n\nknn_lw <- nb2listw(knn, style = \"B\")\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2.html#computing-gi-statistics",
    "href": "Hands-on_Ex2/Hands-on_Ex2.html#computing-gi-statistics",
    "title": "Hands-on_Ex2",
    "section": "Computing Gi Statistics",
    "text": "Computing Gi Statistics\n\nGi Statistics Using Fixed Distance\nThe code chunk below calculates the Gi statistics of the 88 regions using the fixed distance weights matrix.\n\nfips <- order(hunan$County)\ngi.fixed <- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of localG() is a vector of G or Gstar values, with attributes \"gstari\" set to TRUE or FALSE, \"call\" set to the function call, and class \"localG\".\nThe Gi statistics is represented as a Z-score. Greater values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters.\nNext, we will join the Gi values to their corresponding hunan sf dataframe by using the code chunk below.\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\nThe code chunk above performs three tasks. First, it convert the output vector (i.e. gi.fixed) into r matrix object by using as.matrix(). Next, cbind() is used to join hunan and gi.fixed matrix to produce a new SpatialPolygonDataFrame called hunan.gi. Lastly, the field name of the gi values is renamed to gstat_fixed by using rename().\n\n\nGi Statistics Using AdaptiveDistance\nThe code chunk below are used to compute the Gi values for GDPPC2012 by using an adaptive distance weight matrix (i.e knn_lw).\n\nfips <- order(hunan$County)\ngi.adaptive <- localG(hunan$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan.gi, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\nMapping Gi Values with Fixed and Adaptive Distance Weights\nThe code chunk below shows the functions used to map the Gi values derived using fixed and adaptive distance weights matrix.\n\ngdppc <- qtm(hunan, \"GDPPC\", fill.palette = \"Blues\", title = \"GDPPC 2012\")\n\n\nGimap.fixed <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_fixed\",\n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"Local Gi\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Fixed distance weights matrix\",\n            main.title.size = 0.9,\n            main.title.position = \"center\")\n\nGimap.adaptive <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\",\n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"Local Gi\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Adaptive distance weights matrix\",\n            main.title.size = 0.9,\n            main.title.position = \"center\")\n\ntmap_arrange(gdppc,\n           Gimap.fixed,\n           Gimap.adaptive,\n           asp = 1,\n           ncol = 3)\n\nSome legend labels were too wide. These labels have been resized to 0.47, 0.47, 0.47, 0.43. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nOverall, fixed distance method works well for point data. It is often a good option for polygon data when there is large variation in polygon size, and a consistent scale of analysis is desired. Adaptive distance or k-nearest neighbours method, on the other hand, is effective when we want to ensure a minimum number of neighbours in the analysis. This is especially when the values associated with the features are skewed (i.e. not normally distributed), and as a rule of thumb we want to evaluate each feature within the context of at least 8 neighbours.\nWe saw earlier from the histogram of the simulated Moran’s I values that there is a slight right-skew. Here, we observe that the fixed distance method show positive clusters around in the high GDPPC 2012 regions, and negative clusters generally in the West part of Hunan. The adaptive distance method shows a wider area for strong positive clusters in the same high GDPPC 2012 regions, and a more negative cluster in the Southwest region."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html",
    "title": "In-class Exercise 1",
    "section": "",
    "text": "This is my first in-class exercise for geospatial analytics! We will review the key components of Hands-on Exercise 1 and learn more using the data from the In-class Exercise 1 zip file."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#getting-started",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#getting-started",
    "title": "In-class Exercise 1",
    "section": "Getting Started",
    "text": "Getting Started\n\nR packages\nThe code chunk below will install and load tidyverse and sf packages.\n\npacman::p_load(tidyverse, sf)\n\npacman is a wrapper that wraps an installation package and a loading package, so that the package(s) is/are installed and loaded in one breath without having to use install.packages() + library().\nThe syntax pacman:: is necessary because while the package pacman is installed, it is not loaded. Hence, it needs to be specified so that R knows to use p_load() from pacman package.\nWhen rendering, R is making sure that tidyverse and sf packages are installed.\nTo view the (local) webpage in web browser, using the bottom right-hand quadrant of the RStudio > Files > ISSS624 folder > _site > In-class Ex > In-class Ex1 > In-class Ex1.html > left-click select View in Web Browser.\n\n\nData\nUnzip Hands-on_Ex1, copy the data folder to C:/zhuyiting1/ISSS624/In-class_Ex/In-class_Ex1. It should be in the same folder as In-class_Ex1.qmd."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#importing-geospatial-data",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#importing-geospatial-data",
    "title": "In-class Exercise 1",
    "section": "Importing Geospatial Data",
    "text": "Importing Geospatial Data\n\nImporting Polygon Features\nThis code chunk will import ESRI shapefile into R.\n\nmpsz <- st_read(dsn = \"data/geospatial\",\n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\zhuyiting1\\ISSS624\\In-class_Ex\\In-class_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nTo read the syntax of the function, select the function name in the code and press F1. The Help page in the bottom right-hand quadrant of RStudio will open up.\nThe dsn argument is to tell st_read() where is the destination (relative path). As the code document (qmd file) is in the same directory as the data folder, we can start from “data/” to call the data folder within.\nPro tip: Using the bottom right-hand quadrant, go to Files tab, go to the folder/subfolder that we are trying to import the data (in this case data/geospatial) and look at the folder and file names to key in as inputs for st_read().\nFrom the output, we can obtain a couple of information including:\n\nProjected CRS: SVY21 (Singapore-based projected coordinates system). Not in degrees format.\nUnit of measurement: metres.\n\nUnder Environment tab in the top right-hand quadrant of RStudio, mpsz data is loaded in R. Clicking on the blue |> button to the left of mpsz, we can take a quick peek of the dataframe. Up to the first 10 records are displayed (to save space). To look at the dataframe in greater detail, click on the dataframe name mpsz to open the full data table.\n\n\nImporting and Transforming into Projected Coordinate System\nDecimal degree format (between 0o and 360o) good for exact location but not for distance measurement. This is because the Earth is ellipsoid and the distance gets closer further away from the equator in this format.\nOn the other hand, projected coordinate system flattens the Earth. This makes the distance roughly equivalent no matter where we are.\nReading: Geographic vs Projected Coordinate Systems\nTo convert wgs84 (geographic coordinate system) to svy21 (Singapore projected coordinate system), use the function st_transform() and argument crs = 3414.\nThe following code chunk imports the pre-schools location data (kml file) and pipes it into the transformation step in one sitting.\n\npreschool = st_read(\"data/geospatial/pre-schools-location-kml.kml\") %>% \n  st_transform(crs = 3414)\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\zhuyiting1\\ISSS624\\In-class_Ex\\In-class_Ex1\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nWhile the output above still indicates geodetic CRS wgs84, when we click on preschool in the Environment tab to open the data table, we can see that the geometry values are no longer in degree decimal format."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#in-class-exercise-1",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#in-class-exercise-1",
    "title": "In-class Exercise 1",
    "section": "In-class Exercise 1",
    "text": "In-class Exercise 1"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#importing-shapefile-data",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#importing-shapefile-data",
    "title": "In-class Exercise 1",
    "section": "Importing Shapefile Data",
    "text": "Importing Shapefile Data\nNow, let’s add the In-class Ex 1 data in the data folder.\nWe will also need the spdep package for this exercise. We do it by including it in the p_load() function. As it requires the spData package, we will install and load it as well. Finally, we need the tmap package for quick plots.\n\npacman::p_load(spData, tidyverse, sf, spdep, tmap)\n\nWe also want to do some housekeeping to keep our laptop memory freed up from unused datasets. In the Environment tab, click on the broom logo to remove unused datasets.\n\nNow we want to import the Hunan shapefile into R.\n\nhunan <- st_read(dsn = \"data/geospatial\",\n                layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `C:\\zhuyiting1\\ISSS624\\In-class_Ex\\In-class_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\nWe can see that the data is in geodetic CRS wgs84."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#importing-attribute-data-in-csv",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#importing-attribute-data-in-csv",
    "title": "In-class Exercise 1",
    "section": "Importing Attribute Data in CSV",
    "text": "Importing Attribute Data in CSV\n\nAspatial Hunan Data\nThe code chunk below imports the aspatial Hunan 2012 data.\n\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#joining-hunan-data",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#joining-hunan-data",
    "title": "In-class Exercise 1",
    "section": "Joining Hunan Data",
    "text": "Joining Hunan Data\nThe code chunk below joins the spatial and aspatial data for Hunan using the left_join() function of the dplyr package.\n\nhunan <- left_join(hunan, hunan2012)\n\nJoining, by = \"County\"\n\n\nR recognises the variable “County” to be the only common variable between the two dataframes and performs the join accordingly. As the two dataframes have the exact same number of observations with matching county, left_join() here works the same as a inner_join(), right_join() and full_join(). It appends the hunan2012 data to the right of the original hunan data. Notably, the geometry column from the original hunan dataframe remains at the rightmost column of the new hunan dataframe."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#visualising-regional-development-indicator",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#visualising-regional-development-indicator",
    "title": "In-class Exercise 1",
    "section": "Visualising Regional Development Indicator",
    "text": "Visualising Regional Development Indicator\nWith some data about the Hunan province, we want to create a quick thematic map to visualise the distribution of Gross Domestic Product Per Capita (GDPPC) in 2012, using the qtm() function from the tmap package.\n\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.3, \n            legend.width = 0.7)\n  \nquantile <- tmap::tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.3, \n            legend.width = 0.7)\n\ntmap_arrange(equal, quantile, asp = 1, ncol = 2)\n\n\n\n\nWe see that the equal interval classification map shows that most regions (~60%) have GDPPC of only 1/5 of the wealthiest region. In addition, we observe that the wealth is mostly concentrated in the Northeast region of the Hunan province."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#global-spatial-autocorrelation",
    "href": "In-class_Ex/In-class_Ex1/In-class_Ex1.html#global-spatial-autocorrelation",
    "title": "In-class Exercise 1",
    "section": "Global Spatial Autocorrelation",
    "text": "Global Spatial Autocorrelation\nWe want to know whether such a distribution of GDPPC is by pure chance (randomness), and if not, whether there is a positive/negative correlation between neighbouring regions or outliers. To do this, we will compute the global spatial autocorrelation statistics and perform spatial complete randomness test for global spatial autocorrelation.\n\nContiguity Spatial Weights"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS624",
    "section": "",
    "text": "In this webpage, I am going to share with you my learning journey of geospatial analytics."
  }
]